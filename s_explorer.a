
	!src "..\godotlib.lib"
	*= $c000

; ------------------------------------------------ 
;
; sys.Explorer
; goDos System App for File Management
;
; 1.00, 20.08.17, added Input routines
;
; ------------------------------------------------ 


; ------------------------------------------------ Declarations

	pport		= $01
	amrk		= $30		; /$31
	lcnt		= $32
	offout		= $33
	bufoff		= $34
	counter		= $39
	stmerk		= $3b
	xcnt		= $3c
	blcnt		= $3d

	byte		= $a3
	fcolor		= $ac
	tab		= $b0
	offx		= ls_adrmisc
	offy		= offx+1
	icons		= $e0		; constant

	shift		= $028d
	devs		= $0fa2

	sdw10		= $1558		; part of se_scup/dwn
	ui_fill		= $17e0		; Fill Screen /w checkered backgr
	dir4		= $1b69		; part of gd_dir
	dspalte		= $1db3		; system dir window indent

	block		= sy_global	; system dir buffers
	ftrack		= block+96
	dirbuffer		= sy_bigbuffer
	dirname		= dirbuffer+5
	blksfree		= dirbuffer+32
	filetype		= dirbuffer+54
	fftrack		= dirbuffer+160
	buffer		= $cd00		; transport buffer (1 block)

	sprite		= $d015
	rahmen		= $d020
	ciout		= $ffa8
	load		= $ffd5
	clrall		= $ffe7

; ------------------------------------------------ Header

	jmp start
	!by $40			; system module
	!by $00,$00
	!wo modend
	!wo 0
	!pet "U&I Explorer    "
	!pet "1.00"
	!pet "20.08.17"
	!pet "A.Dettke        "

; ----------------------------------------- Main

start	lda #0
	sta ls_dirmask
	sta movefl
	ldx ls_flen
	stx aflen
	ldx ls_showfiles
	stx afiles
	ldx sc_shadow
	stx shdmk
	ldx sc_normtext
	stx sc_shadow
	ldx ls_drive
	stx adrive	; aktueller Drive: 12? (RAM)
	cpx #12
	bne st01
	ldx ls_bootdrive	; dann: Bootdrive
st01	sta ls_flen
	lda sdrive
	bne st0
	txa 
st0	sta sdrive	; Source Drive setzen
	sta ls_showfiles	; Show all aktivieren
	lda ddrive
	bne st1
	txa 
st1	sta ddrive	; Destination Drive setzen

	jsr ui_fill
	ldx #<explrlst	; UI ausgeben
	ldy #>explrlst
	jsr gd_screen
	jsr shsdrv	; Drives zeigen

	ldx #0
	ldy sdrive
	jsr sdr0		; Source Drive: Info
	jsr chkdrvpar	; System Dir Records 

	lda gd_modswitch
	sta aswitch
	jsr gd_eloop	; wait for clicks

	lda adrive	; dann: alles restaurieren
	sta ls_drive
	lda aflen
	sta ls_flen
	lda afiles
	sta ls_showfiles
	lda aswitch
	sta gd_modswitch
	lda shdmk
	sta sc_shadow

; ------------------------------------------------ 

sevquit	sec 		; leave module
	rts 

; ------------------------------------------------ Text Output Handler

tabigad	!wo sdrv		;  0 Source Unit
	!wo header	;  2 Title Bar
	!wo sels		;  4 Source Selector
	!wo blks		;  6 Blocks Free
	!wo enoth		;  8 Error: Nothing selected
	!wo godout	; 10 Fileinfo: which Type
	!wo nam2out	; 12 Fileinfo: which Name
	!wo versout	; 14 Fileinfo: Version
	!wo dateout	; 16 Fileinfo: Date
	!wo aut2out	; 18 Fileinfo: which Author
	!wo lenout	; 20 Fileinfo: Length

settab	lda #<(tabigad)
	sta sc_texttab
	lda #>(tabigad)
	sta sc_texttab+1
	rts 

gettab	lda (sc_texttab),y
	sta sc_screentab
	iny 
	lda (sc_texttab),y
	sta sc_screentab+1
	iny 
	sty sc_merk
	stx sc_merk+1
	lda #0
	tax 
	tay 
gt0	jsr gd_setpos
	cpx #3
	bne gt0
	stx sc_ho
	jsr gd_trim
	jmp gd_initmove

; ------------------------------------------------ Show Unit Number

shsdrv	ldy #0
	lda sdrive	; select source

sh0	sty which
	pha 
	ldx #0
	stx sc_loop
	jsr settab
	jsr gettab
	pla 
	jsr gd_xcnvdez
	ldy #5
	sta (sc_screentab),y; Unit-Number eintragen
	txa 
	dey 
	sta (sc_screentab),y
	ldy #2
	jsr gd_xtxout1	; und anzeigen

	jsr a		; Selektor-Fenster Source färben
	ldy which
	bne cls1
	jsr offset	; mark active drive

cls1	clc 
	rts 

; ------------------------------------------------ Show Status of Source

sevsstat	lda sdrive
sds0	tay 
	lda ls_drive
	sty ls_drive
error	pha 
	jsr gd_xmess	; Floppy-Status ausgeben
	pla 
	sta ls_drive
	jmp gd_spron

; ------------------------------------------------ Event: Select Source Drive

sevsdrive	ldx #0
	lda #3
sdr3	ldy #8		; Drive-Nr. 8
	cmp sc_merk+1	; Klick-Zeile kleiner als 3?
	bcc sdr2
	dec sc_merk	; Klick-Spalte 1?
	beq sdr0
	ldy #10		; Drive-Nr. 10
	bne sdr0
sdr2	iny 		; Drive-Nr. 9
	dec sc_merk
	beq sdr0
	ldy #11		; Drive-Nr. 11

sdr0	tya 
	sta ls_drive
	sta sdrive,x
	jsr gd_sproff
	sta ls_flen
	txa 

sdr1	jsr shsdrv
	jsr dirinfo

; ------------------------------------------------ Directory of Source

sdir	lda #2
	ldy sdrive	; Source
sdir0	sta dspalte	; System-Indent fürs Dir-Fenster ändern
	sty ls_drive
	jsr prepdir
	dec sc_zl
	jsr gd_dir	; System-Directory
	jsr svftrack	; save system track list
	lda ls_track
	sta block+$1d
	lda ls_first
	sta block+$1f
sdir3	lda ls_cblocks
	sta block+$1e
sdir1	lda #5		; System-Indent restaurieren
	sta dspalte

; ------------------------------------------------ Filetype-Info

typeinfo	sta sc_zl		; Zeile 5
	ldx #1		; Breite 1
	stx sc_br
	ldy #0

---	sty sc_loop
	sta sc_sp		; Spalte 5
	jsr gd_initmove

	lda sc_vekt20	; Adresse-256 
	ldx sc_vekt20+1
	sta ls_adrmisc
	dex
	stx ls_adrmisc+1
	lda (sc_vekt20),y
	cmp #$2e		; "." an dieser Stelle?
	bne ofile

	ldx #42		; ja, Index in Typliste setzen
--	lda #0		; Treffer auf 0
	tay
	sta match
	lda #3
	sta three		; Zähler für Typliste
-	dec three
	dey		; .y=$ff
	lda (ls_adrmisc),y
	dex
	cmp types,x	; Vergleich
	bne +		; unzutreffend?
	inc match		; nein, Treffer
	lda match
	cmp #3		; schon 3?
	beq showtype	; dann gefunden
+	lda three		; Types-Zähler auf 0?
	bne -		; nein, nächster Vergleich
	txa		; nächster Typ, Treffer auf 0, .y=$ff
	bpl --		; sonst nächste Zeile

contn	inc sc_zl
	lda #5
	ldy #0
	ldx sc_zl
	cpx #21
	bne ---
finish	clc
	rts

ofile	ldx #25		; Index in divdrei
	cmp #32		; kein Punkt, Leertaste?
	bne contn		; nein, dann keine Anzeige
	ldx #41
	sec
	lda sc_vekt20
	sbc #3
	sta sc_vekt20
	bcs +
	dec sc_vekt20+1
+	ldy #16		; sonst: ganze Zeile leer?
-	dey
	bmi finish	; ja, (vorzeitiges) Ende
	lda (sc_vekt20),y
	cmp #32
	beq -
	bne contn		; sonst: keine Anzeige

showtype	lda divdrei,x	; Index auf das zugehörige Icon
	clc
	adc #icons
	sta sc_movetab
	lda #0
	sta sc_movetab+1
	lda #19
	sta sc_sp
	jsr gd_initmove
	jsr gd_xtxout3
	bcc contn

; ------------------------------------------------ 

prepdir	ldx #3		; Dirfenster Source löschen
	cmp #22
	bcc pd0
pd1	lda ddirwin,x
	sta sc_zl,x
	dex 
	bpl pd1
	lda #16
	bne pd2
pd0	lda sdirwin,x
	sta sc_zl,x
	dex 
	bpl pd0
	lda #18
pd2	sta winwdt
	inx 
	stx sc_loop
	ldy winwdt
	jsr gd_blank
	jsr gd_trim
	jsr gd_initmove
	ldx sc_ho
	jmp gd_fi1

; ------------------------------------------------ 

err	pla 		; leave last routine
	pla 
	jsr err8		; "ERROR" in title bar
	jsr cnva7
	jmp sterr		; Floppy-Status ausgeben

; ------------------------------------------------ LOAD Directory Header

getdirin	lda #3		; 3 Zeichen ("$: ", gets empty dir)

; ------------------------------------------------ LOAD Directory Entry of a File

getfilin	pha 		; .a: Anzahl Zeichen
	jsr gd_sproff
	pla 
	ldx #<dollar	; LOAD "$:" (note: *with* colon!)
	ldy #>dollar
	jsr filnam
	lda #12		; Ch 12
	ldx ls_drive
	ldy #0
	jsr filpar
	lda #0
	tax 
	ldy #>dirbuffer	; in den Directory-Puffer
	sei 
	jsr load
	cli 
	jmp gd_spron

; ------------------------------------------------ Get Diskname and Blocks Free

dirin	lda #32
	sta dirname
	sta dirbuffer+22
	lda #5		; 5: Offset auf Disknamen

; ------------------------------------------------ Get Filename and Filelength

filin	ldy #24		; .a: Offset auf Filenamen
	sty sc_br
	sta sc_texttab
	lda #>dirbuffer
	sta sc_texttab+1
di0	lda (sc_texttab),y	; Namen holen
	sta sc_movetab,y	; in Ausgabepuffer
	sta sy_numbers,y	; und in den Ziffernpuffer
	dey 
	bpl di0
	jsr gd_cnvbc	; nach Petscii wandeln
	ldy #2		; im Header ausgeben
	jsr settab
	jsr gettab
	jsr gd_xtxout3
	jmp getbl		; Blocks Free aufarbeiten

; ------------------------------------------------ 

dirinfo	jsr getdirin	; gewählten Eintrag im Directory laden
	bcs err
	jsr dirin
	tya 		; Offset auf Ende von Blocks-Free-String
	pha 

	ldx #4		; Blocks Free eintragen:
	ldy #7		; Source
	lda which		; oder
	beq di60
	ldy #21		; Destination
di60	lda #32
di6	sta sdrv,y	; zuerst: löschen
	iny 
	dex 
	bpl di6

	pla 		; dann: eintragen
	tay 
	dey 
	ldx #11
	lda which
	beq di3
	ldx #25
di3	lda sy_numbers,y
	sta sdrv,x
	dex 
	dey 
	bpl di3
	jmp shsdrv	; show source

; ------------------------------------------------ Colorize Selector Windows

a	ldy #4
	jsr settab
b	jsr gettab
	inc sc_ho
	ldx #2		; Index auf Hilite
	jmp gd_fcol

; ------------------------------------------------ Highlight active Drive

offset	lda ls_drive	; Drivenummer minus 8 als Index
	and #3
	tax 
	sec 
	lda sc_vekt20
	sbc off,x
	sta sc_vekt20
	bcs os2
	dec sc_vekt20+1
os2	ldy #0
	ldx #2		; Hilite-Farbe anwählen
	lda sc_shadow+1,x
os3	sta (sc_vekt20),y
	iny 
	dex 
	bne os3
	rts 

; ------------------------------------------------ Create # of Blocks

getbl	ldx blksfree
	lda blksfree+1

cntbl	sta $62
	stx $63
	lda #$37		; BASIC on
	sta pport
	ldx #$90
	sec 
	jsr $bc49
	jsr $bddf
	dec pport		; BASIC off
	ldy #6
di2	dey 
	lda sy_numbers,y
	bne di2
	rts 

; ------------------------------------------------ 

cnva6	jsr sterr
cnva7	ldy #0
cnva4	sty ls_flen
stay	clc 
	rts 

; ------------------------------------------------ Event: Select a File

sevselect	lda sc_merk	; Zeile, in der geklickt wurde
	sta sc_zl
	jsr gd_initmove	; umrechnen auf Screenadresse
sel0	lda (sc_vekt20),y	; was dort steht umkopieren
	sta sc_movetab,y	; in den Textausgabepuffer
	sta ls_nambuf,y	; und als Filenamen
	iny 
	cpy #16
	bne sel0
sel1	dey 		; Leerzeichen hinten ausblenden
	lda sc_movetab,y
	cmp #32
	beq sel1
	iny 
	beq cnva4
sel4	sty sc_br		; gleich: Filenamenslänge
	sty ls_flen2
	lda #0
	sta ls_nambuf,y
	jsr gd_cnvasc	; Filenamen nach Petscii wandeln

	lda ls_nambuf	; Koala?
	cmp #$c1		; "A"? (Spades)
	bne sel41
	ldx #2
pic0	lda ls_nambuf+1,x	; "pic"? -> Koala-Name?
	cmp pic,x
	bne sel41		; nein
	dex 
	bpl pic0
	lda #$81		; sonst: Spades ersetzen
	sta ls_nambuf
	lda #32		; und Namen bis Länge 15 mit Space auffüllen
	sta ls_nambuf,y
	ldy #15
	sty ls_flen
	iny 

sel41	dey 
sel5	lda ls_nambuf,y
	sta dollar+2,y	; Namen für Dir eintragen
	sta scratch+2,y	; bei Scratch auch gleich mit
	sta wname,y	; und auch beim Writefile
	dey 
	bpl sel5
	clc 
	lda ls_flen	; Namenslänge um 2 erhöhen (Dos-Kommando vorne)
	adc #2
	pha 		; merken

	adc #2		; und nochmal um 2 für Writefile (",p,w")
	sta wflen
	lda sdrive
	sta ls_drive
	jsr shsdrv	; Source-Drivenummer ausgeben
	pla 

	jsr getfilin	; Dir-Eintrag f. diesen Filenamen holen
	bcc sel63
sel62	jmp cnva6		; bei Fehler: Diskmessage
sel63	ldy #0
sel61	lda filetype,y	; Filetype suchen (ab dieser Position)
	iny 
	cmp #32
	beq sel61
	sta wtype+1	; richtigen Filetype für OPEN einsetzen

	ldy #$22		; "b" von "blocks free"?
	lda dirbuffer,y
	cmp #$42
	beq sel62		; dann Fehler (File nicht gefunden)

sel6	iny 
	lda dirbuffer,y
	cmp #34		; öffnendes Anführungszeichen suchen
	bne sel6
	tya 		; Index in Dirbuffer auf den Namen setzen
	jsr filin		; Filenamen holen
	lda blksfree	; dann Dateilänge:
	sta filelen
	lda blksfree+1
	sta filelen+1
	ldx #4
	lda #32		; Blocks-Anzeige löschen
sel7	sta blocks,x
	dex 
	bpl sel7 		; .y zeigt auf den Delimiter ($00)
	dey
	ldx #4		; und Dateilänge eintragen
sel8	lda sy_numbers,y
	sta blocks,x
	dex 
	dey 
	bpl sel8
	ldy #3
	ldx wflen
sel71	dex 
	lda wtype,y	; ",p,w" an Writefilenamen anhängen
	sta wname,x
	dey 
	bpl sel71
sel81	ldy #6		; Dateilänge anzeigen
sel82	jsr gettab
	ldy #2
	jsr gd_xtxout1

; ------------------------------------------------ FileInfo: Read First Block

	jsr gd_sproff
	lda #<(dollar+2)
	sta ls_vekta8
	lda #>(dollar+2)
	sta ls_vekta8+1
	ldx ls_flen
	bne +
	jmp nothing
+	stx ls_temp
	lda sdrive
	sta ls_drive
	jsr sopen
	bcc +
	jmp err6
+	ldx #13
	jsr chkin
	ldx #0
-	jsr basin
	sta buffer,x
	inx
	bit status
	bvs +
	txa
	bne -
+	jsr clrch
	jsr err6

; ------------------------------------------------ FileInfo: Show 

	jsr settab

	ldx #0
	stx xcnt		; Type-Index auf 0
	stx lcnt		; Zeilenzähler auf 0
	stx bufoff
	lda buffer+1
	cmp #$ca
	bne +
	lda buffer
	cmp #$64
	bne ++
	lda #$4c
	sta bufoff
++	ldx #3
	stx xcnt
	bne ++
+	cmp #$c0		; Startadresse $c000?
	beq +
-	jmp notsys
+	lda buffer+2
	cmp #$4c		; beginnt mit JMP?
	bne -

	lda buffer+5	; Type
-	asl
	bcc +
	stx xcnt
+	inx
	cpx #5
	bcc -

++	ldy #15
	lda #12
	jsr txf1
	ldy #12		; Name out
	jsr fio1

	ldx xcnt
	lda type_o,x
	tax
	jsr fi_fill
	ldy #15
	lda #<godtx
	ldx #>godtx
	jsr txf2
	ldy #10		; Type out
	jsr fi_out

	ldy #15
	lda #16
	jsr txf1
	ldy #11
	lda #<verstx
	ldx #>verstx
	jsr txf2
	ldy #14
	jsr fi_out
	
	ldy #15
	lda #24
	jsr txf1
	lda #<datetx
	ldx #>datetx
	ldy #7
	jsr txf2
	ldy #16		; Date out
	jsr fi_out
	
	ldy #13
	lda #<lentx
	ldx #>lentx
	jsr txf2
	ldx buffer+8
	lda buffer+9
	and #$3f
	jsr cntbl
	ldx #15
	dey
-	lda sy_numbers,y
	sta fouttx,x
	dex
	dey
	bpl -
	ldy #20		; Length out
	jsr fi_out
	
	ldy #15
	lda #40
	jsr txf1
	ldy #18		; Author out
	jsr fi_out

	clc
	rts

fi_out	inc lcnt
fio1	ldx lcnt
	lda txoffs,x
	sta offout
	jsr gettab	; .y: Offset auf Record-Adresse
	jsr cnvbc
	ldy offout	; .y: Offset auf Textadresse
	jmp gd_xtxout1

	
notsys	lda #22
	jsr prepdir
	clc
	rts

; ------------------------------------------------ Fehler

nothing	ldy #8		; Nothing selected
	jmp err7

; ------------------------------------------------ 

fi_fill	ldy #2
-	lda type_s,x
	sta godtx,y
	lda type_t,x
	sta godtx+12,y
	dex
	dey
	bpl -
	rts

tx_fill	ldy #7
txf1	clc
	adc bufoff
	ldx #>buffer
txf2	sta amrk
	stx amrk+1
-	lda (amrk),y
	sta fouttx,y
	dey
	bpl -
	rts

cnvbc	ldx #15
-	lda fouttx,x
	beq +
	eor #$e0
	clc
	adc #32
	bpl +
	adc #64
	bpl +
	eor #$a0
+	sta fouttx,x
	dex
	bpl -
	rts

; ------------------------------------------------ Event: Delete a File

sevdel	ldy ls_flen
	beq nothing
nameit	jsr gd_sproff	; Routine wird für Rename mitverwendet
	iny 
	iny 
	tya 
	ldx #<scratch	; Scratch File senden
	ldy #>scratch
	jsr gd_sendcom
	jmp cnva6		; Floppy-Meldung

; ------------------------------------------------ Initialize

inull	ldx #<init	; "I0" senden
	ldy #>init
	lda #2
	jsr gd_sendcom
err9	jsr gd_xmess
	lda ls_err2	; Rückmeldung checken
	and #15
err5	sec 
	rts 

; ------------------------------------------------ Open Source

sopen	lda #13		; 13,drive,13
	tay 
	ldx sdrive
	beq err5
	jsr filpar
	lda ls_temp
	ldx ls_vekta8
	ldy ls_vekta8+1
	jsr filnam
	jmp copen

; ------------------------------------------------ ERROR

err6	lda #13
	jsr close
	jsr gd_xmess
	jmp gd_spron

err8	ldx #4
er80	lda ermess,x	; "ERROR" in Titel ausgeben
	sta blocks,x
	dex 
	bpl er80
	ldy #6		; blks anwählen

; ------------------------------------------------ Errors

err7	jsr settab
	jsr gettab
	ldy #2
	jmp gd_xtxout1

; ------------------------------------------------ Event: Scroll Source

sevsupdn	lda sc_merk	; Klick-Zeile
	sta merkzl
	lda sdrive
	sta ls_drive
	jsr shsdrv
	lda #2

destud	sta dspalte
	lda block+$1d
	sta ls_track

	lda merkzl	; wo geklickt?
	cmp #17		; up oder down?
	bcs up
dn	ldy block+$1e
	bne sdw4
	ldy #2
sdw4	iny 
	tya 
	!by $2c
up	lda #1
	pha 

	lda dspalte	; System-Indent
	jsr prepdir
	pla 
	tay 
sdw5	ldx block
	dex 
	bne sdw2
	ldy block+$1f
	inx 
	sty block+1
	bne sdw11
sdw0	dex 
	bne sdw2
	inx 
sdw2	dey 
	bne sdw0
sdw1	ldy block,x
sdw11	lda fftrack,x
	sta ls_track
	stx block
	ldx #4
	stx sc_zl
	ldx #1
	jsr dir4		; System Directory
	jsr svftrack
	jmp sdir3		; restore system dir (dspalte)

; ------------------------------------------------ Event: Input Filename

sevfinput	lda #32
	ldy ls_flen	; Filename vorhanden?
	beq fierr		; nein, nothing selected
	iny 
	sta (sc_vekt20),y
	ldy #0
	sta (sc_vekt20),y
ip0	inc sc_vekt20
	bne ip01
	inc sc_vekt20+1
ip01	lda sc_br
	pha 
	lda #17
	sta sc_br
	jsr gd_xinput	; System-Input
	pla 
	sta sc_br
	lda sc_vekt20
	bne ip02
	dec sc_vekt20+1
ip02	dec sc_vekt20
	ldy ls_len
	dey 
	beq fierr
	bmi fierr
	tya 
	sta ls_flen
	clc 
	adc #4
	sta wflen
ip4	ldy #34
ip1	iny 
	lda dirbuffer,y
	cmp #34
	bne ip1
	ldx #$ff
ip2	inx 
	iny 
	lda ls_nambuf,x	; überall eintragen
	sta dirbuffer,y
	sta dollar+2,x
	sta scratch+2,x
	sta wname,x
	cpx ls_flen
	bne ip2
	lda #34
	sta dirbuffer,y
	lda #32
ip6	iny 
	sta dirbuffer,y
	cpy #56
	bne ip6
	ldy #34
	jmp sel6		; anzeigen

; ------------------------------------------------ 

fierr	jmp nothing

; ------------------------------------------------ 

sterr	lda ls_drive
	jmp error

; ------------------------------------------------ Event: Rename

sevrename	ldy ls_flen
	beq fierr
	sty alen
rn0	lda scratch+1,y	; Namen umtragen für Rename
	sta rename,y
	dey 
	bne rn0
	inc alen
	jsr settab
	ldy #2		; title bar ansteuern
	jsr gettab
	ldy #12
	jsr setptr	; Mauszeiger an die richtige Stelle setzen
	jsr sevfinput	; neuen Namen holen
	lda sy_tbuffer	; Stop?
	cmp #3
	beq sterr
	ldy ls_flen
	beq fierr
	ldx #0
rn1	lda rename,x
	sta scratch+2,y	; eintragen
	iny 
	inx 
	cpx alen
	bne rn1
	lda #$52		; "r" (Rename)
	sta scratch
	clc 
	lda alen
	adc ls_flen
	tay 
	jsr nameit	; rename file senden
	lda #$53		; "s" (Scratch)
	sta scratch
	jsr cnva7
	lda #5
	sta merkzl
	dec block+$1e
	jmp destud-2	; Ergebnis anzeigen

; ------------------------------------------------ Event: DOS (Input a DOS Command)

sevdos	jsr gd_clrms
	ldy #188
	jsr setptr	; Mauszeiger setzen
	lda ls_flen
	pha 
	jsr gd_xinput	; System-Input
	pla 
	sta ls_flen
	ldy ls_len
	dey 
	beq fierr0
	bmi fierr0
	jsr gd_sproff
	tya 
	ldx #<ls_nambuf	; Kommando senden
	ldy #>ls_nambuf
	jsr gd_sendcom
	jmp cnva6		; Floppy-Meldung
fierr0	jmp fierr		; Error: Nothing selected

; ------------------------------------------------ Mauszeiger setzen

setptr	tya 
	clc 
	adc sy_soffy
	sta $d003
	tay 
	dey 
	dey 
	sty $d001
	rts 

; ------------------------------------------------ Screenlist

explrlst	!by $00

	!by 17,33,3,3,$40
	!wo stay
	!by 17,34,3,3,$40
	!wo stay
	!by 17,35,3,3,$40
	!wo sevrename

	!by 0,1,38,25,$21
	!wo 0

sels	!by 0,1,7,4,$f4
	!wo sevsdrive
	!scr " 8  9@"

header	!by 0,8,26,3,$65
	!wo sevfinput

	!by 0,34,5,3,$b6
	!wo 0
	!scr "U&I@"

sdirwin	!by 4,1,20,18,$68
	!wo sevselect

ddirwin	!by 4,21,18,11,$2f
	!wo 0

	!by 15,21,3,4,$d0
	!wo sevsupdn
	!by 30,0				; Hochpfeil

	!by 19,21,3,3,$c0
	!wo sevsstat
	!scr "?@"

	!by 15,24,6,3,$c0
	!wo stay
	!scr "Inst@"

	!by 15,30,8,3,$c0
	!wo stay
	!scr "Launch@"

	!by 18,24,8,3,$40			; ChDir
	!wo stay
	!by 19,24,8,3,$40			; ChPart
	!wo stay
	!by 18,24,8,4,$00
	!wo 0

	!by 19,32,6,3,$c0
	!wo sevquit
	!scr "Exit@"

	!by 22,3,34,3,$ac
	!wo 0
	!scr "- goDos Explorer -@"

	!by $c0,18,24,5
	!scr "ChDir@"
	!by $c0,19,24,6
	!scr "ChPart@"

	!by $c0,1,1,5
	!scr "10 11@"

	!by $c0,16,21,1
	!by 31,0				; Abpfeil

	!by $c0
sdrv	!by 2,7,11
	!scr "U  :     @"			; Unit

	!by $c0
	!by 2,21,9
	!scr "FileInfo:@"

	!by $c0
	!by 17,33,3
	!scr "NDR@"

	!by $80

; ------------------------------------------------ Messages

enoth	!by 22,3,34
	!scr "       Nothing selected.        @"
ermess	!pet "error"

type_s	!pet "DEVUNISYSAPP"
type_t	!pet "DEVMODSVRLDR"
type_o	!by 11,8,5,2
txoffs	!by 2,5,8,11,14,17
aut2out	!by 11,21,18
lenout	!by 9,21,18
dateout	!by 8,21,18
versout	!by 7,21,18
godout	!by 5,21,18
nam2out	!by 4,21,18
fouttx	!pet "................"
	!by 0
godtx	!pet "xxx (GoDot: xxx)"
datetx	!pet "Date:   "
verstx	!pet "Version:    "
lentx	!pet "Length:       "

; ------------------------------------------------ Data

adrive	!by 0
aflen	!by 0
alen	!by 0
aswitch	!by 0
sdrive	!by 0
ddrive	!by 0
winwdt	!by 18

; ------------------------------------------------ Text Buffers

dollar	!pet "$:"
	!fill 17,32
scratch	!pet "s:"
	!fill 36,32
rename	!pet "="
	!fill 17,32
wname	!fill 21,32
wtype	!pet ",p,w"
init	!pet "i0"

; ------------------------------------------------ Data

wflen	!by 0
which	!by 0
off	!by 80,77,40,37
blks	!by 0,27,7	; 7 wird auf 5 getrimmt!
blocks	!by 32,32,32,32,32,0
pic	!pet "pic"
disklen	!wo $ffff
filelen	!wo 0
mwrite	!pet "m-w"	; address Floppy 0, write 1 ("ok")
	!by 0,0,1,1
mwlen	!by 7
merkzl	!by 0
afiles	!by 0
movefl	!by 0
shdmk	!by 0
types	!scr "modsysappunildrsvrdev"
	!scr "4btfntspsconpatgod"
divdrei	!by 0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6
	!by 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8
match	!by 0
three	!by 3

; ------------------------------------------------ 

svftrack	ldx #64
cdp2	lda ftrack-1,x	; Chain of Tracks in Dir Window
	sta fftrack-1,x	; save it
	dex 
	bne cdp2
	rts 

; ------------------------------------------------ Get System Dir Sector Chain

chkdrvpar	ldx #192
	jsr cdp2
	lda sdrive
	cmp ddrive
	bne cdp0
	ldx #31
cdp1	lda block,x
	sta block+$40,x
	dex 
	bpl cdp1
	lda ls_cblocks
	sta block+$1e
	sta block+$5e
	lda ls_first
	sta block+$1f
	sta block+$5f
	lda ls_track
	sta block+$1d
	sta block+$5d
cdp0	rts 

; ------------------------------------------------ Patch 1541 Job Bug

check41	ldx ls_drive
	lda devs,x
	and #$f0
	cmp #$40
	bne cdp0
	ldx #<mwrite	; m-w 0 0 1 1 ($01 nach $00)
	ldy #>mwrite	; means: job for buffer 0 returns ok
	lda mwlen
	jmp gd_sendcom

; ------------------------------------------------ Activity Handler

messout	ldx #<(message)
	ldy #>(message)
	jmp gd_xtxout2

tcopy	ldy #0
tc0	lda txt,x
	beq clrmess
	sta message,y
	inx 
	iny 
	bne tc0

action	inc blcnt		; übertragene Blöcke zählen
	bne ac0
	inc blcnt+1
ac0	dec counter	; Gauge counter
	bne ld4

	lda cntwert	; abgelaufen, neu setzen
	sta counter
	ldy #3
ac2	lda sc_descriptor,y	; Screen descriptor retten
	pha 
	dey 
	bpl ac2
	ldx blcnt		; Block Counter in Ziffern wandeln
	lda blcnt+1
	jsr cntbl
	ldx #9
	dey 
ac1	lda sy_numbers,y	; und in Message eintragen
	sta message,x
	dex 
	dey 
	bpl ac1
	ldy #0
ac4	pla 
	sta sc_descriptor,y	; Screen descriptor rekonstruieren
	iny 
	cpy #4
	bne ac4
	ldy offy
	cpy #22
	bne +
	jsr clrmess
+	ldx offx
	lda filltab,x	; Gauge-Balken verlängern
	sta mess,y
	jsr messout	; Gauge ausgeben
	dec offx		; Zähler ggf. resetten
	bpl ld4
	inc offy
	lda #7
	sta offx
ld4	rts 

clrmess	ldx #20
	lda #32
cl0	sta mess,x
	dex 
	bpl cl0
	ldy #0
	ldx #7
	sty offy
	stx offx
	rts 

filltab	!by 160,93,103,127,126,124,105,109

cntwert	!by 1

txt	!scr " Copy:    @"
	!scr " Move:    @"
	!scr " Bitmap @"

message	!fill 11,32
mess	!fill 21,32
	!by $00

; ------------------------------------------------ 

modend	!eof

; ------------------------------------------------ 


