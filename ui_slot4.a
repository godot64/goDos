
!src "..\godotlib.lib"
*= $c000

;    ---------------------------------------------------   
; ***                                                   ***
; ***  formerly: GoDot UpMem                            ***
; ***                                                   ***
; ***                                                   ***
; ***                                                   ***
; ***  1.08, 22.08.92,                                  ***
; ***                                                   ***
; ***  1.10, 14.11.92                                   ***
; ***  1.11, 22.11.92                                   ***
; ***  1.12, 03.02.93                                   ***
; ***  1.13, 02.04.93                                   ***
; ***  1.14, 16.08.93,                                  ***
; ***        01.11.00, complete comment revision        ***
; ***                                                   ***
;    ---------------------------------------------------   
;
; UI Slot4
; Upmem fraction of goDos kernel
;
; 0.99, 14.08.17, removed Palette, Balancing, Guru, Dither Mode and Clip Status
;                 added Input
;
;
; -------------------------------------------------- Declarations

	pport		= $01		; usually $36

	src		= $39
	col00		= $3b
	nr0		= $40
	max		= $44
	rstart		= max
	rend		= max+1
	cols		= $46
	zp1		= $47
	xbuf		= $48
	rstep		= xbuf
	hmzp		= $49
	cmzp		= $4a
	pbuf		= $4b

	source		= $a6
	dest		= $a8
	lflag		= $a8
	brttmp		= $a9
	crttmp		= $aa
	vblock		= $aa
	bitcnt		= $ac
	source1		= $ae
	dest1		= $b2
	hold		= $b4
	vblock1		= $b5

	sprptr		= $07fa

	spr2		= $3e80
	spr5		= $3f40
	hist1		= $3f40
	hist		= $3f50
	etab		= $3f70
	htab		= $3f80
	htab0		= $3f90
	rtab		= $3fb0

	dbuf		= $bf00

	sprxy		= $d004
	xmsb		= $d010
	grafreg		= $d011
	sprreg		= $d015
	multreg		= $d016
	yexp		= $d017
	charreg		= $d018
	sprpri		= $d01b
	sprmulti		= $d01c
	xexp		= $d01d
	border		= $d020
	backgr		= $d021
	sprcol2		= $d025
	sprcol3		= $d026
	sprcol1		= $d029

	oszi3		= $d40e
	wave		= $d412
	filter		= $d418
	rausch		= $d41b

	cstart		= $fe0b
	vram1		= $de0b
	vram2		= $ee0b

; -------------------------------------------------- Header

	jmp start
	!by $20
	!wo 0
	!wo modend
	!wo 0
	!pet "goDos f000 slot4"
created	!pet "0.99"
	!pet "14.08.17"
	!pet "A.Dettke        "

; -------------------------------------------------- Module Management

start	ldx sc_screenvek	; save vector to main screen screenlist
	stx list
	ldx sc_screenvek+1
	stx list+1

	ldx gr_nr		; get function number
	beq jevbal	; 0: not used
	dex
	beq jinput	; 1: Input
	dex
	beq jevdispl	; 2: Display
	dex
	beq jevdith	; 3: not used
	dex
	beq jevarea	; 4: not used
	dex
	beq jevinfo	; 5: not used
	dex
	beq jevprviu	; 6: Switch Preview on
	dex
	beq jevdisp2	; 7: Redisplay

leave	clc
	rts

jevdispl    jmp evdisplay
jinput      jmp initinp
jevbal      jmp leave
jevdith     jmp leave
jevarea     jmp leave
jevprviu    jmp evprviu
jevdisp2    jmp evdisp2
jevinfo     jmp leave

; -------------------------------------------------- 
; -------------------------------------------------- Show graphics
; -------------------------------------------------- 

redisplay	ldx gr_palette	; bordercolor is palette entry 0
	stx border
	jsr setcolors	; reget colors
	lda gr_cmode	; which graphics mode?
	beq dp4
	lda #$18		; multi when 2
	sta multreg
dp4	lda #$1b		; hires when 0
	sta charreg
	lda #$3b
	sta grafreg
	lda gr_redisp	; image already rendered?
	bne dp3
	sta sc_keyprs	; yes, clear keypressed
	pla		; clear stack
	pla
dp1	lda sc_keyprs	; wait for key or STOP
	ora sc_stop
	beq dp1
	jsr getcolors	; save colors
	jsr tmode		; switch textmode on
	lda sc_screenvek	; save vector to current screenlist
	pha
	lda sc_screenvek+1
	pha
	lda pdis		; is palette requester working?
	beq dp5
	ldx list		; yes, rebuild main screen
	ldy list+1
	jsr gd_screen
dp5	pla		; rebuild palette requester
	tay
	pla
	tax
	jsr gd_screen
dp3	clc		; finished (stay in list)
	rts

; -------------------------------------------------- Switch Textmode on

tmode	ldx #$13
	lda #$1b
	stx charreg
	sta grafreg
	lda #$08
	sta multreg
	lda sc_maincolor
	sta border
	sta backgr
	rts

; -------------------------------------------------- Graphics Colors Management

setcveks	sei		; called from GETCOLORS
	lda #$35		; set C64 to IO off
	sta pport
	lda #>(cstart)	; first: save 1000 color RAM nibbles to loader area
	ldx #$d8		; from $d800
	bne scv0
setbveks	lda #>(vram1)	; second: save upper 500 video RAM bytes to saver area
	ldx #$04		; from $0400
	dec pport		; set C64 completely to RAM
scv0	stx dest1+1
	ldy #$00
	sty sc_merk
	sty dest1
	dey
setlast	sty gr_bkcol	; third: save lower 500 video RAM bytes to module area
	ldy #<(cstart)
	sty sc_vekt20	; vector to data
	sta sc_vekt20+1
	lda #<(500)	; counter
	sta ls_vekta8
	lda #>(500)
	sta ls_vekta8+1
	ldy #$00
	rts

; -------------------------------------------------- Counters

count	inc sc_vekt20	; increment source data vector
	bne cou5
	inc sc_vekt20+1
cou5	inc dest1		; increment destination data vector
	bne cou6
	inc dest1+1
cou6	lda ls_vekta8	; decrement counter
	bne cou7
	dec ls_vekta8+1
cou7	dec ls_vekta8
	lda ls_vekta8	; until zero
	ora ls_vekta8+1
	rts

; -------------------------------------------------- Save Graphics Colors

getcolors	jsr setcveks	; set vectors accordingly
stco	lda (dest1),y	; compress $d800-nibbles
	sta sc_merk
	inc dest1
	bne stc0
	inc dest1+1
stc0	lda (dest1),y
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lda sc_merk
	sta (sc_vekt20),y	; and buffer them
	jsr count
	bne stco

	jsr setbveks	; buffer video RAM, part 1
stc1	lda (dest1),y
	sta (sc_vekt20),y
	jsr count
	bne stc1
	ldy gr_bkcol	; flag: last time?
	bpl scv1		; yes, finished

	ldy #$00		; buffer video RAM, part 2
	lda #>(vram2)
	jsr setlast
	beq stc1		; unconditional branch

scv1	lda #$36		; set C64 to BASIC off
	sta pport
	cli
	lda backgr	; set graphics background color value
	and #$0f
	sta gr_bkcol
	rts

; -------------------------------------------------- Restore Graphics Colors

setcolors	lda gr_bkcol	; restore background color
	sta backgr
	pha		; save for last time

	jsr setcveks	; set vectors accordingly
stc2	sty sc_merk	; decompress color RAM nibbles
	lda (sc_vekt20),y
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	sta (dest1),y	; and store them
	inc dest1
	bne stc3
	inc dest1+1
stc3	lda sc_merk
	sta (dest1),y
	jsr count
	bne stc2

	jsr setbveks	; restore video RAM, part 1
stc4	lda (sc_vekt20),y
	sta (dest1),y
	jsr count
	bne stc4

	ldy gr_bkcol	; flag: last time?
	bpl scv1		; yes, finished

	pla		; restore video RAM, part 2
	tay
	lda #>(vram2)
	jsr setlast
	beq stc4

; ### removed:
; -------------------------------------------------- 
; -------------------------------------------------- Palette Management
; -------------------------------------------------- 

tabigad	;	!wo pickbox	; text output routines
	;	!wo palbox
	;	!wo pick

settab	lda #<(tabigad)
	sta sc_texttab
	lda #>(tabigad)
	sta sc_texttab+1
	rts

gettab	lda (sc_texttab),y
	sta sc_screentab
	iny
	lda (sc_texttab),y
	sta sc_screentab+1
	iny
	sty sc_merk
	stx sc_merk+1
	lda #$00
	tax
	tay
gt0	jsr gd_setpos
	cpx #$04
	bne gt0
	jsr gd_trim
	jmp gd_initmove


; -------------------------------------------------- 
; -------------------------------------------------- Event Re-Display Graphics
; -------------------------------------------------- 

evdisp2	lda gr_redisp	; save current re-display status
	pha
	ldx #$01		; force re-display
	stx gr_redisp
	dex		; clear STOP key
	stx sc_stop
	jsr redisplay	; re-display
	jsr dp1		; wait for keypress
	pla		; restore redisp status
	sta gr_redisp
	rts

; -------------------------------------------------- Event Display Graphics

evdisplay	jsr redisplay	; display graphics

	lda #$80		; initialize noise (random) values
	sta filter
	sta oszi3
	sta oszi3+1
	lda #$00
	sta wave
	sta sc_stop
	lda #$81
	sta wave

	lda gr_howmany	; number of colors to be rendered
	sta hmzp		; store in zeropage
	lda gr_cmode	; get graphics mode
	sta cmzp		; and store to zeropage
	jsr setvecs	; initialize all vectors and values
	jsr setclip	; compute startaddress of clip

	lda dest		; destination ($2000)
	ldx dest+1
	sta dest1
	stx dest1+1
	jsr clrclip	; clear clip area and provide histograms

	lda source	; source ($4000)
	ldx source+1
	sta source1
	stx source1+1
	lda vblock	; video RAM ($0400)
	ldx vblock+1
	sta vblock1
	stx vblock1+1

	ldx gr_dither	; set vector of current dither routine
	lda routtablo,x
	sta sc_pos
	lda routtabhi,x
	sta sc_pos+1

; -------------------------------------------------- 

mainpix	lda sc_clipho	; height
	sta sc_ho
dhb4	lda sc_clipbr	; width
	sta sc_br

dhb1	clc
	lda #$00		; init indeces
	sta sc_merk
	sta sc_merk+1
dhb01	jsr histo		; compute histogram for 1 tile

dhb0	ldy sc_merk	; get first byte (2 4bit pixels)
	lda (source),y
	pha
	ldy cmzp		; color mode
	bne mcskip	; multi?
	lsr		; no hires, get first 4b pixel (left)
	lsr
	lsr
	lsr
mcskip	and #$0f		; isolate 4b pixel
	tax		; care for balancing (gray: contrast/brightness)
	lda gr_btab,x
	ldy sc_merk+1	; index for "Ordered" pattern
	jsr pixel		; dither, returns a bitpattern
	and bitcnt	; isolate bitmap pixel position
	ora (dest),y	; and set bm pixel
	sta (dest),y
	lsr bitcnt	; next bm pixel position

	pla		; re-get 4bit byte (right pixel)
	and #$0f		; isolate 4b pixel
	tax
	lda gr_btab,x	; balancing, .y still valid
	jsr pixel		; dither, returns a bitpattern
	and bitcnt	; isolate bm pixel
	ora (dest),y	; and set 
	sta (dest),y

	inc sc_merk	; inc index into tile
	lsr bitcnt	; next pixel position
	bcc dhb0

	ror bitcnt	; 8 pixels finished, reset mask
	inc sc_merk+1	; inc index into Ordered pattern
	lda sc_merk+1
	cmp #$08		; 8 scanlines finished?
	bcc dhb01

	inc vblock	; yes, next tile:
	bne dhb21
	inc vblock+1

dhb21	clc		; add 8 to dest vector
	adc dest
	sta dest
	bcc dhb2
	inc dest+1
dhb2	clc		; add 32 to source vector
	lda #$20
	adc source
	sta source
	bcc dhb3
	inc source+1

dhb3	lda sc_stop	; STOP pressed?
	bne break		; yes, break

	dec sc_br		; decrement width value
	bne dhb1		; until zero

; -------------------------------------------------- 

	clc		; to tile below first:
	lda vblock1	; add 40 to video RAM
	adc #$28
	sta vblock1
	sta vblock
	lda vblock1+1
	adc #$00
	sta vblock1+1
	sta vblock+1
	clc		; add 320 to dest
	lda dest1
	adc #$40
	sta dest1
	sta dest
	lda dest1+1
	adc #$01
	sta dest1+1
	sta dest+1
	clc		; add 1280 to source
	lda source1+1
	adc #$05
	sta source1+1
	sta source+1
	lda source1
	sta source

	dec sc_ho		; dec height
	beq dhb9		; until zero

	jmp dhb4		; else loop

; -------------------------------------------------- 

break	sta gr_redisp	; force re-render
	sta sc_keyprs	; simulate keypressed
dhb9	jmp dp1		; end sequence (graphics off...)

; -------------------------------------------------- 
; -------------------------------------------------- Dither Routines
; -------------------------------------------------- 

pixel	jmp (sc_pos)	; entry for dither routines

; -------------------------------------------------- Compute Clip data

setclip	lda sc_clipzl	; row of clip
	beq scp1		; zero?

	sta sc_zl		; no, increment video RAM by 40
scp4	clc
	lda vblock
	adc #$28
	sta vblock
	bcc scp2
	inc vblock+1
scp2	clc		; increment dest by 320
	lda dest
	adc #$40
	sta dest
	lda dest+1
	adc #$01
	sta dest+1
	clc		; increment source by 1280
	lda source+1
	adc #$05
	sta source+1
	dec sc_zl		; as many times as vertically indented
	bne scp4

scp1	lda sc_clipsp	; column of clip
	beq scp5		; zero?

	sta sc_sp
scp8	inc vblock	; no, inc video by 1
	bne scp81
	inc vblock+1
scp81	clc		; inc dest by 8
	lda dest
	adc #$08
	sta dest
	bcc scp6
	inc dest+1
scp6	clc		; inc source by 32
	lda source
	adc #$20
	sta source
	bcc scp7
	inc source+1
scp7	dec sc_sp		; as many times as horizontally indented
	bne scp8

scp5	rts

; -------------------------------------------------- Dith type: No Dither

dithoff	tax		; regard quantization table
	lda gr_qtab,x
	tax		; get appropriate pixel pattern ($0 or $f)
	lda htab,x
	rts

; -------------------------------------------------- Dith type: Ordered 

dithhab	sta zp1
	tax		; regard quantized colors
	lda rtab,x
	ora offs,y	; compute offset into pattern
	tax
	lda gr_orderedpat,x	; get pixel pattern
	jmp dh1		; regard graphics mode

; -------------------------------------------------- Dith type: Pattern

dithpat	sta zp1
	sty hold		; save .y (pattern index)
	tax
	lda rtab,x	; regard quantized colors
	asl		; times 8
	asl
	asl
	ora hold		; regard index
	tax
	lda gr_pattern,x	; get pixel pattern

dh1	ldx cmzp		; grahics mode?
	beq dp0
	and #$0f		; if multi:
	tax		; get appropriate pixel pattern
	lda mcpat,x
dp0	ldx zp1		; get original value
	and bitcnt	; isolate bm pixel
	beq bgr		; not set?
	bne fgr		; set?

; -------------------------------------------------- Dith type: Random

dithrnd	tax
	lda rtab,x	; regard quantized colors
	beq bgr
	cmp #8		; threshold: 8
	bcs fgr

	lda rtab+1,x	; regard neighboring color
	beq dr0
	cmp #8
	bcc bgr

dr0	jsr getrnd	; get random value
rold	lda zp1
	and #1
	beq bgr		; even?
	bne fgr		; odd?

; -------------------------------------------------- Dith type: Noise

dithnoi	tax
	lda rtab,x	; regard quantized colors
	beq bgr
	sta hold		; no threshold
	jsr getrnd	; get random value
nold	lda hold
	cmp zp1		; bigger?
	bcs fgr

; -------------------------------------------------- 

bgr	lda htab0,x	; pixel not set, get pixel pattern
	rts

fgr	lda htab,x	; pixel set, get pixel pattern
	rts

; -------------------------------------------------- Get Random Value

getrnd	lda cmzp		; graphics mode?
	beq gr00
	lda bitcnt	; multi, isolate right pixels
	and #$55
	bne gr01
gr00	lda rausch	; hires, get random value
	and #15		; delimit to 15
	sta zp1
gr01	rts

; -------------------------------------------------- 
; -------------------------------------------------- Clip Routines
; -------------------------------------------------- 


; -------------------------------------------------- Get start values

setvecs	lda #$00
	sta sc_keyprs	; clear keyboard
	sta gr_redisp	; clear re-render flag
	sta vblock	; low bytes all $00
	sta source
	sta dest
	lda sc_clipped	; any clip set?
	bne sv0		; yes, don't change values

	sta sc_clipzl	; no, values to 0,0,40,25
	sta sc_clipsp
	lda #$19
	sta sc_clipho
	lda #$28
	sta sc_clipbr

sv0	lda #$80		; init bitmask for pixel pattern
	sta bitcnt
	lsr		; source from $4000
	sta source+1
	lsr		; dest from $2000
	sta dest+1
	lda #$04		; video from $0400
	sta vblock+1
	rts

; -------------------------------------------------- Clear Clip Area

clrclip	ldx sc_clipho	; height of clip
	ldy #$00

cc2	sty sc_pos+1
	lda sc_clipbr	; width of clip times 8
	asl
	asl
	asl
	bcc cc3
	inc sc_pos+1
cc3	sta sc_pos

	lda dest		; save dest
	pha
	lda dest+1
	pha

cc0	tya		; .y=0 
	sta (dest),y	; clear bytes (to black)
	inc dest
	bne cc1
	inc dest+1
cc1	lda sc_pos	; count width
	bne cc4
	dec sc_pos+1
cc4	dec sc_pos
	lda sc_pos	; until 0
	ora sc_pos+1
	bne cc0

	pla
	sta dest+1
	pla
	clc		; add 320 to dest
	adc #$40
	sta dest
	lda dest+1
	adc #$01
	sta dest+1
	dex		; decrement height
	bne cc2

	lda dest1		; restore dest
	ldx dest1+1
	sta dest
	stx dest+1

; -------------------------------------------------- 

	lda gr_dither	; any dither?
	beq hist0		; no, compute histograms

	lda hmzp		; yes, get number of colors/grays
	cmp #$02		; b&w?
	bne makeetab	; no, create etab and compute histograms

; -------------------------------------------------- 

	lda cmzp		; yes, b&w, graphics mode?
	beq mcb
	lda #$55		; multi, get pattern $55
	!by $2c
mcb	lda #$ff		; hires, pattern $ff
	ldy #$0f

hm2l	sta htab,y	; put to table of pixel patterns
	eor #$ff
	sta htab0,y
	eor #$ff
	tax
	tya
	sta rtab,y	; put to table of quantized colors
	txa
	dey
	bpl hm2l

	lda gr_palette+1	; get neighboring color
	asl		; shift to upper nibble
	asl
	asl
	asl
	ora gr_palette	; or with color
	sta pbuf		; store value (faster rendering now)
	rts

; -------------------------------------------------- 

makeetab	ldy #$01
	ldx #$00
etl	lda gr_qtab,y	; compare neighboring values in quantization table
	cmp gr_qtab-1,y
	beq ets		; if equal, ignore
	tya
	sta etab,x	; if not, set position of change to etab
	inx
ets	iny
	cpy #$10
	bne etl

; -------------------------------------------------- Make Histograms

hist0	ldx #$2f		; clear histograms
	stx col00+4
	jsr clh1

	sta src		; start from $4000
	lda #$40
	sta src+1
	lda cmzp		; get graphics mode
	beq hi01
	lda #$aa		; is multi: change bits
hi01	sta bits+2
	beq hready	; finished when hires

	lda sc_clipped	; any clip?
	beq hloop		; no, proceed

	ldy hmzp		; yes, number of colors/grays
	dey
cll1	lda gr_palette,y	; background color part of palette?
	cmp backgr
	beq cls1		; yes, store index
	dey
	bpl cll1
	ldy #$20		; no, set flag
cls1	sty bktmp
hready	rts		; no histograms when clipped

; -------------------------------------------------- Histograms for Multi Mode

hloop	jsr clrhist1	; clear histogram1

	ldy #$1f		; retrieve colors
l1	lda (src),y
	and #$0f
	tax
	lda gr_btab,x	; regard balancing and quantization
	tax
	lda gr_qtab,x
	tax
	inc hist1,x
	dey
	bpl l1

	ldy #$00		; how many colors per tile?
	ldx hmzp
	dex
	sty col00
l2	lda hist1,x
	beq s11
	iny
s11	dex
	bpl l2
	cpy #$04		; less than 4?
	bcc s2		; yes, proceed

	ldx hmzp		; no, count colors in these particular tiles
	dex
l3	lda hist1,x
	beq s3
	clc
	adc hist,x
	sta hist,x
	bcc s3
	inc hist+16,x
s3	dex
	bpl l3

s2	lda src		; next tile
	clc
	adc #$20
	sta src
	bcc hloop
	inc src+1
s4 	lda src+1
	cmp #$bd		; end of 4bit?
	bne hloop

; -------------------------------------------------- 

	lda #$00		; yes, retrieve most frequent color
	sta max
	sta max+1
	ldx hmzp
	dex
l4	lda hist+16,x
	tay
	cmp max+1
	bcc s5
	beq s51
	lda hist,x
	bcs s52
s51	lda hist,x
	cmp max
	bcc s5
	beq s5
s52	sta max
	sty max+1
	stx col00		; contains most frequent color
s5	dex
	bpl l4

	lda col00		; result becomes background color
	tax
	lda gr_palette,x
	stx bktmp
	sta backgr
	rts

; -------------------------------------------------- 

clrhist1	ldx hmzp
	dex
clh1	lda #$00
l5	sta hist1,x
	dex
	bpl l5
	rts

; -------------------------------------------------- Decide which colors per tile

histo	lda gr_dither	; any dither?
	beq dohist	; no, histogram

	lda hmzp		; b&w?
	cmp #2
	bne dohist	; no, histogram

	lda pbuf		; yes, get precomputed colors
	ldy #0
	sta (vblock),y
	rts

; -------------------------------------------------- 

dohist	jsr clrhist1	; clear histogram

	ldy #$20		; preset values (impossible value 32)
	sty col00+3
	sty col00+2
	sty col00+1
	dey

l6	lda (source),y	; count colors
	pha
	and #$0f
	tax
	lda gr_btab,x
	tax
	lda gr_qtab,x
	tax
	inc hist1,x
	pla
	ldx cmzp
	bne s6
	lsr
	lsr
	lsr
	lsr
	tax
	lda gr_btab,x
	tax
	lda gr_qtab,x
	tax
	inc hist1,x
s6	dey		; within 64 pixels
	bpl l6

	ldy cmzp		; graphics mode
	beq s7

	ldx bktmp		; is multi:
	stx col00
	lda #$00		; don't regard background color
	sta hist1,x
	sta nr0
s7	ldx #$03
l7	 ldy #$00
	sty max
	lda bits,x
	sta nr0,x
l8	lda hist1,y
	beq s8
	cmp max
	bcc s8
	sta max
	sty col00,x	; get 3 most frequent colors
s8	iny
	cpy hmzp
	bne l8
	ldy col00,x	; don't regard processed colors
	lda #$00
	sta hist1,y
	dex
	bne l7

; -------------------------------------------------- Set Colors

	ldy #$00
	lda cmzp		; graphics mode
	beq mc1

	lda col00+1	; is multi: get video RAM colors
	and #$0f
	tax
	lda gr_palette,x
	asl
	asl
	asl
	asl
	sta cols
	lda col00+2
	and #$0f
	tax
	lda gr_palette,x
	ora cols
	sta (vblock),y	; and set

	lda vblock+1	; color 3 to color RAM
	pha
	clc
	adc #$d4
	sta vblock+1
	lda col00+3
	and #$0f
	tax
	lda gr_palette,x
	sta (vblock),y
	pla
	sta vblock+1
	bne mc2		; unconditional branch

mc1	ldx col00+2	; is hires: get video RAM colors
	cpx #$20		; only 1 color in tile?
	bne ms1
	ldx col00+3	; yes, get neighboring color for background
	inx
	cpx hmzp
	bne ms2
	dex
	dex
ms2	stx col00+2

ms1	lda col00+3	; sort colors (when hires)
	cmp col00+2
	bpl nosort
	ldx col00+2
	sta col00+2
	stx col00+3
	txa
nosort	and #$0f
	tax
	lda gr_palette,x
	asl
	asl
	asl
	asl
	sta cols
	lda col00+2
	and #$0f
	tax
	lda gr_palette,x
	ora cols
	sta (vblock),y	; and set
	jmp makehtab	; make pattern table

mc2	ldx #$00		; sort colors (when multi)
lx	stx xbuf
	ldy #$03
ly	lda col00,x
	cmp col00,y
	bcc s9
	beq s9
	pha
	lda col00,y
	sta col00,x
	pla
	sta col00,y
	lda nr0,x
	pha
	lda nr0,y
	sta nr0,x
	pla
	sta nr0,y
s9	dey
	cpy xbuf
	bne ly
	inx
	cpx #$03
	bne lx

; -------------------------------------------------- Create Pixelpattern Table

makehtab	lda gr_dither	; any dither?
	bne makertab	; yes, branch

	ldy #$ff
	sty max
	lda cmzp		; graphics mode
	bne l9
	ldy #$01		; is hires (.y=2)
l9	iny		; is multi (.y=0)
	lda col00,y	; compute average of 2 neighboring colors
	clc
	adc col00+1,y
	lsr
	cmp #$10
	bcc s10
	lda #$0f
s10	sta max+1
	lda nr0,y
	ldx max
l10	inx
	sta htab,x	; fill table
	cpx max+1
	bcc l10
	cpx #$0f
	bcs l12
	stx max
	cpy #$03
	bne l9
l12	rts

; -------------------------------------------------- Create transition patterns

makertab	ldx #$00
	lda cmzp		; graphics mode
	bne mkt0
	ldx #$02		; is hires (.x=2)
mkt0	ldy #$00		; is multi (.x=0)
mkt1	lda gr_qtab,y
	cmp col00+1,x
	bcs mkt2
	lda nr0+1,x
	sta htab,y
	lda nr0,x
	sta htab0,y
	iny
	cpy #$10
	bne mkt1
	beq mrt0
mkt2	inx
	cpx #$04
	bne mkt1

mrt0	ldy #$0f
	lda #$00
irl	sta rtab,y	; set pattern (transition between two neighboring colors)
	dey
	bpl irl

	ldx #$00
	lda cmzp
	bne rtl0
	ldx #2
rtl0	lda col00,x
	cmp #$20
	bcs rts0
	tay
	lda etab,y
	sta rstart
	lda col00+1,x
	cmp #$20
	bcs rts0
	tay
	dey
	lda etab,y
	sta rend
	sec
	sbc rstart
	beq rts1
	tay
	lda rdtab,y
	sta rstep
	ldy rstart
	lda #$00
rtl1	clc
	adc rstep
	pha
	lsr
	lsr
	lsr
	lsr
	sta rtab,y
	iny
	cpy rend
	pla
	bcc rtl1
rts1	inx
	cpx #$04
	bne rtl0
rts0	rts

; -------------------------------------------------- Pixel Patterns

bits	!by $00,$55
	!by $aa,$ff
mcpat	!by $00,$03,$0c,$0f,$30,$33,$3c,$3f
	!by $c0,$c3,$cc,$cf,$f0,$f3,$fc,$ff
rdtab	!by $f0,$78,$50,$3c,$30,$28,$22
	!by $1e,$1b,$18,$16,$14,$12,$11,$10

routtablo	!by <(dithoff),<(dithhab),<(dithpat),<(dithnoi),<(dithrnd)
routtabhi	!by >(dithoff),>(dithhab),>(dithpat),>(dithnoi),>(dithrnd)
offs	!by $00,$10,$20,$30,$00,$10,$20,$30

; ### removed:
; -------------------------------------------------- 
; -------------------------------------------------- Event: Toggle Clip/Full
; -------------------------------------------------- 


; ### removed:
; -------------------------------------------------- 
; -------------------------------------------------- Event: Toggle Dither Type
; -------------------------------------------------- 

; ### removed:
; -------------------------------------------------- 
; -------------------------------------------------- Event: Balancing Requester
; -------------------------------------------------- 


; -------------------------------------------------- 

list	!by $00,$00
bktmp	!by 0
pdis	!by 0

; -------------------------------------------------- 
; -------------------------------------------------- Event: Display Preview
; -------------------------------------------------- 

; When entering this event routine you have just clicked the 
; appropriate gadget. So, all values are still set here and now.
; The event routine first reverts the gadget's background.


evprviu	jsr gd_initmove	; compute screen address
	pha		; A-reg contains sc_vekt20+1
	lda sc_vekt20
	pha
	jsr gd_invert	; reverting to black

	ldx #$c0		; make space for three sprites...
	ldy #$00
loop1	lda spr2-1,x
	sta dbuf-1,x
	tya
	sta spr2-1,x	; and initialize to $00
	dex
	bne loop1

	ldx #$c0		; initialize three more sprites
loop2	sta spr5-1,x
	dex
	bne loop2

	sta sprpri	; priority
	sta xexp		; no expansion
	sta yexp

	lda #$fc		; sprites 2 to 7: multi mode
	sta sprmulti

	ldx #$05		; colorize: mid gray
	lda #$0c
loop3	sta sprcol1,x
	dex
	bpl loop3
	lda #$0b		; dark gray
	sta sprcol2
	lda #$0f		; light gray
	sta sprcol3

	ldx #$0b		; define positions (in gadget)
loop4	lda xytab,x
	sta sprxy,x
	dex
	bpl loop4
	lda xmsb		; beyond 255
	ora #$fc
	sta xmsb

	ldx #$05		; activate sprite pointers
	ldy #$ff
ploop	tya
	sta sprptr,x
	dey
	dex
	bpl ploop

	lda #$ff		; switch sprites on
	sta sprreg

; Now rendering the 4Bit Area to the sprites. Will be done as three
; bands of 12 tiles down from left to right.
; 
	ldx #$02		; three times 12 tiles (20 rows down)
m0loop	txa
	pha
	lda srcl,x	; set source address (4Bit)
	sta sc_pos
	lda srch,x
	sta sc_pos+1
	lda dstl,x	; set destination address (sprites)
	sta sc_loop
	lda dsth,x
	sta sc_loop+1
	lda #$00		; counter to skip byte 63 in sprite
	sta sc_screentab
	jsr makeit	; render one band
	pla
	tax
	dex
	bpl m0loop	; and the next two

; now rendered, wait for click to shut down sprites
; 
	inx		; wait for click
	stx sc_keyprs
wait	lda sc_keyprs
	beq wait

	lda #3		; only sprites 0+1 remain (mouse)
	sta sprreg
	lda xmsb		; force to lower 256 position
	and #$03		; (sometimes flickers, can't imagine why)
	sta xmsb

	pla		; restore gadget address
	sta sc_vekt20
	pla
	sta sc_vekt20+1
	jsr gd_invert	; revert to blue again

	ldx #$c0		; restore rendered image from buffer
piu0	lda dbuf-1,x
	sta spr2-1,x
	dex
	bne piu0

	clc		; don't leave screenlist
	rts
;------------------------------------------------------------------

; rendering 4Bit Area to 6 sprites

;------------------------------------------------------------------
makeit	ldx #$00		; MUST be $00!
	ldy #$14		; 20 rows of tiles down

prloop	tya		; start preview loop
	pha
	lda #$40		; flag: %0100 0000, 2 passes per tile
	sta lflag

dzloop	lda #$03		; flag: 3 passes across
	sta brttmp

zloop	ldy #$60		; 4 tiles from right to left
	lda lflag		; on 2nd pass (tile): 
	bpl bloop
	ldy #$70		; indent to 4 pixels below

bloop	lda (sc_pos),y	; get 4bit data
	lsr
	lsr
	lsr
	ror crttmp
	lsr
	ror crttmp

	tya		; next tile (to the left)
	sec
	sbc #$20
	tay
	bpl bloop

	lda crttmp	; byte complete, write to sprites
	sta (sc_loop,x)

skip64	inc sc_loop	; increment destination pointer
	bne s1
	inc sc_loop+1

s1	inc sc_screentab	; skip byte 63
	lda sc_screentab
	cmp #$3f
	beq skip64

	lda sc_pos	; add to 4 tiles ahead
	clc		; (summing up to 12 tiles at last)
	adc #$80
	sta sc_pos
	bcc skip
	inc sc_pos+1

skip	ror brttmp	; loop for next two passes across
	bcs zloop

	lda sc_pos	; 3 times 4 tiles backwards
	sec
	sbc #$80
	sta sc_pos
	lda sc_pos+1
	sbc #$01
	sta sc_pos+1

	rol lflag		; loop for second pass within tile
	bcc dzloop

	lda sc_pos	; add $500 (1280): next row of tiles
	clc
	adc #$00
	sta sc_pos
	lda sc_pos+1
	adc #$05
	sta sc_pos+1

	pla		; count 20 times
	tay
	dey
	bpl prloop
	rts		; until finished

;-------------------------------------------------------------
; Data (screen positions and so on)
;-------------------------------------------------------------

srcl	!by $40,$c0,$40	; not from leftmost position!
srch	!by $4d,$4b,$4a

dstl	!by $80,$00,$80	; sprite block addresses
dsth	!by $3f,$3f,$3e

xytab	!by $07,$91,$07,$a6
	!by $1f,$91,$1f,$a6
	!by $37,$91,$37,$a6
	!by $00

; ### removed:
; -------------------------------------------------- 
; -------------------------------------------------- Event: GoDot Guru
; -------------------------------------------------- 


; --------------------------- 
; --------------------------- Input Routines

!src "..\input.inc"

; --------------------------- 
; --------------------------- 

; -------------------------------------------------- 

modend	!eof		; end of upmem routines
