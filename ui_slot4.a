
!src "..\godoslib.lib"
*= $c000

; -------------------------------------------------- 
;
; U&I Slot4
; Upmem fraction of goDos kernel
;
; 0.99, 14.08.17, removed Palette, Balancing, Guru, Dither Mode and Clip Status
;                 added Input
; 0.01, 27.08,17, added: FileInfo for Explorer
; 0.02, 29.08.17, added: Screen Cache
;
; -------------------------------------------------- Declarations

	pport		= $01		; usually $36

	amrk		= $30		; /$31
	xcnt		= $32
	lcnt		= $33
	bufoff		= $34
	offout		= $35
	lflag		= $a8
	brttmp		= $a9
	crttmp		= $aa

	sprptr		= $07fa

	spr2		= $3e80
	spr5		= $3f40

	dbuf		= $bf00

	sprxy		= $d004
	xmsb		= $d010
	sprreg		= $d015
	yexp		= $d017
	sprpri		= $d01b
	sprmulti		= $d01c
	xexp		= $d01d
	sprcol2		= $d025
	sprcol3		= $d026
	sprcol1		= $d029

; ------------------------------------------------ 

	vram		= $0400
	cram		= $d800
	ui_vcache		= $b500
	ui_ccache		= $b900

; ------------------------------------------------ 

	fileopen		= $1c9e
	fileclose		= $1b12
	buffer		= $cd00		; transport buffer (1 block)

; -------------------------------------------------- Header

	jmp start
	!by $20
	!wo 0
	!wo modend
	!wo 0
	!pet "goDos f000 slot4"
created	!pet "0.02"
	!pet "29.08.17"
	!pet "A.Dettke        "

; -------------------------------------------------- Module Management

start	ldx sc_screenvek	; save vector to main screen screenlist
	stx list
	ldx sc_screenvek+1
	stx list+1

	ldx gr_nr		; get function number
	beq leave		; 0: not used
	dex
	beq jinput	; 1: Input
	dex
	beq jevcache	; 2: Cache Screen
	dex
	beq leave		; 3: not used
	dex
	beq leave		; 4: not used
	dex
	beq jevinfo	; 5: File Info
	dex
	beq jevprviu	; 6: Switch Preview on
	dex
	beq leave		; 7: not used

leave	clc
	rts

jinput	jmp initinp
jevinfo	jsr evinfo
listback	lda list
	sta sc_screenvek
	lda list+1
	sta sc_screenvek+1
	rts
jevcache	jmp evcache
jevprviu	jmp evprviu

list	!wo 0

; -------------------------------------------------- 
; -------------------------------------------------- Event: File Info
; -------------------------------------------------- 

; ------------------------------------------------ FileInfo: Read First Block

evinfo	jsr gd_sproff	; get filename
	lda #<ls_nambuf
	sta ls_vekta8
	lda #>ls_nambuf
	sta ls_vekta8+1
	ldx ls_flen
	bne +
	jmp err7		; no file selected

+	stx ls_temp
	jsr fileopen
	bcc +
	jmp err6

+	ldx #0		; get one block
-	jsr basin
	sta buffer,x
	inx
	bit status
	bvs +
	txa
	bne -
+	jsr clrch
	jsr err6

; ------------------------------------------------ FileInfo: Show 

info	stx ui_cacheflg	; .x=0, cache flag auf 0
	jsr evcache	; und Screen cachen
	ldx #<infolst	; open info requester
	ldy #>infolst
	jsr gd_screen
	ldx list
	ldy list+1
	stx sc_screenvek
	sty sc_screenvek+1
	
	jsr settab

	ldx #0
	stx xcnt		; Type-Index auf 0
	stx lcnt		; Zeilenzähler auf 0
	stx bufoff

	ldx buffer
	stx strtadr
	lda buffer+1	; file=device?
	sta strtadr+1
	cmp #$ca
	bne +
	cpx #$64
	bne ++
	lda #$4c		; ja, anderer Offset
	sta bufoff
++	ldx #3
	stx xcnt
	bne ++

+	cmp #$c0		; Startadresse $c000?
	beq +
-	jmp other
+	lda buffer+2
	cmp #$4c		; beginnt mit JMP?
	bne -

	lda buffer+5	; Type
-	asl
	bcc +
	stx xcnt
+	inx
	cpx #5
	bcc -

++	ldy #15
	lda #12
	jsr txf1
	ldy #2		; Name out
	jsr fio1

	ldx xcnt
	lda type_o,x
	tax
	jsr fi_fill
	ldy #15
	lda #<godtx
	ldx #>godtx
	jsr txf2
	ldy #0		; Type out
	jsr fi_out

	ldy #15
	lda #16
	jsr txf1
	ldy #11
	lda #<verstx
	ldx #>verstx
	jsr txf2
	ldy #4		; Version out
	jsr fi_out
	
	ldy #15
	lda #24
	jsr txf1
	lda #<datetx
	ldx #>datetx
	ldy #7
	jsr txf2
	ldy #6		; Date out
	jsr fi_out
	
	ldy #13
	lda #<lentx
	ldx #>lentx
	jsr txf2
	ldx buffer+8
	lda buffer+9
	and #$3f
	jsr cntbl
	ldx #15
	dey
-	lda sy_numbers,y
	sta fouttx,x
	dex
	dey
	bpl -
	ldy #10		; Length out
	jsr fi_out
	
	ldy #15
	lda #40
	jsr txf1
	ldy #8		; Author out

; ------------------------------------------------ 

fi_out	inc lcnt
fio1	ldx lcnt
fio2	lda txoffs,x
	sta offout
	jsr gettab	; .y: Offset auf Record-Adresse
	jsr cnvbc
	ldy offout	; .y: Offset auf Textadresse
	jmp gd_xtxout1
	
; ------------------------------------------------ 

fi_fill	ldy #2
-	lda type_s,x
	sta godtx,y
	lda type_t,x
	sta godtx+12,y
	dex
	dey
	bpl -
	rts

tx_fill	ldy #7
txf1	clc
	adc bufoff
	ldx #>buffer
txf2	sta amrk
	stx amrk+1
-	lda (amrk),y
	sta fouttx,y
	dey
	bpl -
	rts

; ------------------------------------------------ 

cnvbc	ldx #15
-	lda fouttx,x
	beq +
	eor #$e0
	clc
	adc #32
	bpl +
	adc #64
	bpl +
	eor #$a0
+	sta fouttx,x
	dex
	bpl -
	rts

; ------------------------------------------------ 

cntbl	sta $62
	stx $63
	lda #$37		; BASIC on
	sta pport
	ldx #$90
	sec 
	jsr $bc49
	jsr $bddf
	dec pport		; BASIC off
	ldy #6
di2	dey 
	lda sy_numbers,y
	bne di2
	rts 

; ------------------------------------------------ 

other	ldx #15
	lda #32
-	sta fouttx,x
	dex
	bpl -
	lda #<ls_nambuf
	ldx #>ls_nambuf+1
	ldy ls_flen
	dey
	jsr txf2
	jsr cnvbc
	ldy #2
	jsr fio1		; Filename out
	ldy #13
	lda #<strttx
	ldx #>strttx
	jsr txf2
	ldx strtadr
	lda strtadr+1
	jsr cntbl
	ldx #15
	dey
-	lda sy_numbers,y
	sta fouttx,x
	dex
	dey
	bpl -
	ldx #1
	ldy #0		; Startadress out
	jmp fio2

; ------------------------------------------------ on ERROR

err6	jsr fileclose
err7	jmp gd_spron

; ------------------------------------------------ Text Output Handler

tabigad	!wo godout	;  0 Fileinfo: which Type
	!wo nam2out	;  2 Fileinfo: which Name
	!wo versout	;  4 Fileinfo: Version
	!wo dateout	;  6 Fileinfo: Date
	!wo aut2out	;  8 Fileinfo: which Author
	!wo lenout	; 10 Fileinfo: Length

settab	lda #<(tabigad)
	sta sc_texttab
	lda #>(tabigad)
	sta sc_texttab+1
	rts 

gettab	lda (sc_texttab),y
	sta sc_screentab
	iny 
	lda (sc_texttab),y
	sta sc_screentab+1
	iny 
	sty sc_merk
	stx sc_merk+1
	lda #0
	tax 
	tay 
gt0	jsr gd_setpos
	cpx #4
	bne gt0
	dex
	clc		; Höhe zu groß?
	lda sc_ho
	adc sc_zl
	cmp #25
	bcc +
	stx sc_ho		; dann: 3 (eff.: 1)
+	jsr gd_trim
	jmp gd_initmove

; ------------------------------------------------ Screenlist

infolst	!by $00
	!by 5,20,18,10,$40
	!wo leave
	!by $80

; ------------------------------------------------ Data for Info

type_s	!pet "DEVUNISYSAPP"
type_t	!pet "DEVMODSVRLDR"
type_o	!by 11,8,5,2
txoffs	!by 2,5,8,11,14,17
aut2out	!by 12,20,18
lenout	!by 10,20,18
dateout	!by 9,20,18
versout	!by 8,20,18
godout	!by 6,20,18
nam2out	!by 5,20,18
fouttx	!fill 16,32
	!by 0
godtx	!pet "xxx (GoDot: xxx)"
datetx	!pet "Date:   "
verstx	!pet "Version:    "
lentx	!pet "Length:       "
strttx	!pet "Start:        "
strtadr	!wo 0

; -------------------------------------------------- 
; -------------------------------------------------- Event: Cache Screen
; -------------------------------------------------- 

; This routine will cache the complete textscreen and their colors
; to $b500 (up to $bcff). If you have something to cache, you just
; call ev_display from main, or go jsr evcache from within Slot4.
; First call caches, next call uncaches. Be sure to set ls_temp to
; $00 before first call.

evcache	ldy ui_cacheflg
	bmi cc1

	lda #>vram
	ldx #>ui_vcache
	jsr swap
	lda #>cram
	ldx #>ui_ccache
	jsr swap
	dey
	bmi cc2

cc1	lda #>ui_vcache
	ldx #>vram
	jsr swap
	lda #>ui_ccache
	ldx #>cram
	jsr swap

cc2	sty ui_cacheflg
	rts

swap	sta ls_vekta8+1
	txa
	sta sc_pos+1
	ldy #0
	sty ls_vekta8
	sty sc_pos
	ldx #4
-	lda (ls_vekta8),y
	sta (sc_pos),y
	iny
	bne -
	inc ls_vekta8+1
	inc sc_pos+1
	dex
	bne -
	rts

; -------------------------------------------------- 
; -------------------------------------------------- Event: Display Preview
; -------------------------------------------------- 

; When entering this event routine you have just clicked the 
; appropriate gadget. So, all values are still set here and now.
; The event routine first reverts the gadget's background.

evprviu	jsr gd_initmove	; compute screen address
	pha		; A-reg contains sc_vekt20+1
	lda sc_vekt20
	pha
	jsr gd_invert	; reverting to black

	ldx #$c0		; make space for three sprites...
	ldy #$00
loop1	lda spr2-1,x
	sta dbuf-1,x
	tya
	sta spr2-1,x	; and initialize to $00
	dex
	bne loop1

	ldx #$c0		; initialize three more sprites
loop2	sta spr5-1,x
	dex
	bne loop2

	sta sprpri	; priority
	sta xexp		; no expansion
	sta yexp

	lda #$fc		; sprites 2 to 7: multi mode
	sta sprmulti

	ldx #$05		; colorize: mid gray
	lda #$0c
loop3	sta sprcol1,x
	dex
	bpl loop3
	lda #$0b		; dark gray
	sta sprcol2
	lda #$0f		; light gray
	sta sprcol3

	ldx #$0b		; define positions (in gadget)
loop4	lda xytab,x
	sta sprxy,x
	dex
	bpl loop4
	lda xmsb		; beyond 255
	ora #$fc
	sta xmsb

	ldx #$05		; activate sprite pointers
	ldy #$ff
ploop	tya
	sta sprptr,x
	dey
	dex
	bpl ploop

	lda #$ff		; switch sprites on
	sta sprreg

; Now rendering the 4Bit Area to the sprites. Will be done as three
; bands of 12 tiles down from left to right.
 
	ldx #$02		; three times 12 tiles (20 rows down)
m0loop	txa
	pha
	lda srcl,x	; set source address (4Bit)
	sta sc_pos
	lda srch,x
	sta sc_pos+1
	lda dstl,x	; set destination address (sprites)
	sta sc_loop
	lda dsth,x
	sta sc_loop+1
	lda #$00		; counter to skip byte 63 in sprite
	sta sc_screentab
	jsr makeit	; render one band
	pla
	tax
	dex
	bpl m0loop	; and the next two

; now rendered, wait for click to shut down sprites
; 
	inx		; wait for click
	stx sc_keyprs
wait	lda sc_keyprs
	beq wait

	lda #3		; only sprites 0+1 remain (mouse)
	sta sprreg
	lda xmsb		; force to lower 256 position
	and #$03		; (sometimes flickers, can't imagine why)
	sta xmsb

	pla		; restore gadget address
	sta sc_vekt20
	pla
	sta sc_vekt20+1
	jsr gd_invert	; revert to blue again

	ldx #$c0		; restore rendered image from buffer
piu0	lda dbuf-1,x
	sta spr2-1,x
	dex
	bne piu0

	clc		; don't leave screenlist
	rts
;------------------------------------------------------------------

; rendering 4Bit Area to 6 sprites

;------------------------------------------------------------------
makeit	ldx #$00		; MUST be $00!
	ldy #$14		; 20 rows of tiles down

prloop	tya		; start preview loop
	pha
	lda #$40		; flag: %0100 0000, 2 passes per tile
	sta lflag

dzloop	lda #$03		; flag: 3 passes across
	sta brttmp

zloop	ldy #$60		; 4 tiles from right to left
	lda lflag		; on 2nd pass (tile): 
	bpl bloop
	ldy #$70		; indent to 4 pixels below

bloop	lda (sc_pos),y	; get 4bit data
	lsr
	lsr
	lsr
	ror crttmp
	lsr
	ror crttmp

	tya		; next tile (to the left)
	sec
	sbc #$20
	tay
	bpl bloop

	lda crttmp	; byte complete, write to sprites
	sta (sc_loop,x)

skip64	inc sc_loop	; increment destination pointer
	bne s1
	inc sc_loop+1

s1	inc sc_screentab	; skip byte 63
	lda sc_screentab
	cmp #$3f
	beq skip64

	lda sc_pos	; add to 4 tiles ahead
	clc		; (summing up to 12 tiles at last)
	adc #$80
	sta sc_pos
	bcc skip
	inc sc_pos+1

skip	ror brttmp	; loop for next two passes across
	bcs zloop

	lda sc_pos	; 3 times 4 tiles backwards
	sec
	sbc #$80
	sta sc_pos
	lda sc_pos+1
	sbc #$01
	sta sc_pos+1

	rol lflag		; loop for second pass within tile
	bcc dzloop

	lda sc_pos	; add $500 (1280): next row of tiles
	clc
	adc #$00
	sta sc_pos
	lda sc_pos+1
	adc #$05
	sta sc_pos+1

	pla		; count 20 times
	tay
	dey
	bpl prloop
	rts		; until finished

;-------------------------------------------------------------
; Data (screen positions and so on)
;-------------------------------------------------------------

srcl	!by $40,$c0,$40	; not from leftmost position!
srch	!by $4d,$4b,$4a

dstl	!by $80,$00,$80	; sprite block addresses
dsth	!by $3f,$3f,$3e

xytab	!by $07,$91,$07,$a6
	!by $1f,$91,$1f,$a6
	!by $37,$91,$37,$a6
	!by $00

; --------------------------- 
; --------------------------- Input Routines

!src "..\input.inc"

; --------------------------- 
; --------------------------- 

; -------------------------------------------------- 

modend	!eof		; end of upmem routines
